# -*- coding: utf-8 -*-
"""DermaDetector

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L1gvGR7GTK9lb7tM4M5yWASRCqjHLO0t
"""

from google.colab import files
import zipfile
import os

# Upload zip file
uploaded = files.upload()  # This will open file picker

# Unzip the uploaded file
for fn in uploaded.keys():
    if fn.endswith('.zip'):
        with zipfile.ZipFile(fn, 'r') as zip_ref:
            zip_ref.extractall("skin_data")  # Extract to folder
            print("Extracted to /content/skin_data")

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout, BatchNormalization
import matplotlib.pyplot as plt
import os

# Set dataset path
data_dir = r"/content/skin_data/skin_dataset"

# 3. Image Parameters
img_size = (128, 128)
batch_size = 32
num_classes = 7

# 4. Data Augmentation and Preprocessing
datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2,
    rotation_range=20,
    zoom_range=0.2,
    horizontal_flip=True,
    shear_range=0.1
)

train_data = datagen.flow_from_directory(
    data_dir,
    target_size=img_size,
    batch_size=batch_size,
    class_mode='categorical',
    subset='training',
    shuffle=True
)

val_data = datagen.flow_from_directory(
    data_dir,
    target_size=img_size,
    batch_size=batch_size,
    class_mode='categorical',
    subset='validation',
    shuffle=False
)

# 5. CNN Model
model = Sequential([
    Conv2D(32, (3,3), activation='relu', input_shape=(*img_size, 3)),
    BatchNormalization(),
    MaxPooling2D(2,2),

    Conv2D(64, (3,3), activation='relu'),
    BatchNormalization(),
    MaxPooling2D(2,2),

    Conv2D(128, (3,3), activation='relu'),
    BatchNormalization(),
    MaxPooling2D(2,2),

    Flatten(),
    Dropout(0.5),
    Dense(128, activation='relu'),
    Dense(num_classes, activation='softmax')
])

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# 6. Train the model
history = model.fit(
    train_data,
    epochs=15,
    validation_data=val_data
)

# Training Accuracy (Last Epoch)
train_acc = history.history['accuracy'][-1]
val_acc = history.history['val_accuracy'][-1]

print(f"\nüìà Final Training Accuracy: {train_acc * 100:.2f}%")
print(f"üìä Final Validation Accuracy: {val_acc * 100:.2f}%")

# 8. Save the model
model.save("skin_disease_cnn_model.h5")
print("‚úÖ Model saved as skin_disease_cnn_model.h5")

# 9. Plot training history
plt.plot(history.history['accuracy'], label='Train Acc')
plt.plot(history.history['val_accuracy'], label='Val Acc')
plt.title('Model Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.grid()
plt.show()

# 10. Class Index Mapping
print("Class Index Mapping:")
print(train_data.class_indices)

model.summary()

import matplotlib.pyplot as plt
import numpy as np

# Reset validation generator to get first batch
val_data.reset()

# Get one batch of validation images
x_val, y_val = next(val_data)

# Predict
preds = model.predict(x_val)
predicted_labels = np.argmax(preds, axis=1)
true_labels = np.argmax(y_val, axis=1)

# Get label mapping
label_map = {v: k for k, v in val_data.class_indices.items()}

# Plotting
plt.figure(figsize=(15, 8))
for i in range(10):
    plt.subplot(2, 5, i + 1)
    plt.imshow(x_val[i])
    plt.axis('off')
    true_label = label_map[true_labels[i]]
    pred_label = label_map[predicted_labels[i]]
    color = 'green' if true_label == pred_label else 'red'
    plt.title(f"Actual: {true_label}\nPredicted: {pred_label}", color=color)

plt.tight_layout()
plt.suptitle("‚úÖ Actual vs Predicted (Validation Set)", fontsize=16, y=1.05)
plt.show()

# Reset train generator to get fresh batch
train_data.reset()

# Get a batch of training images and labels
x_train_batch, y_train_batch = next(train_data)

# Predict on the batch
train_preds = model.predict(x_train_batch)
predicted_train_labels = np.argmax(train_preds, axis=1)
true_train_labels = np.argmax(y_train_batch, axis=1)

# Get label mapping
label_map = {v: k for k, v in train_data.class_indices.items()}

# Plot Actual vs Predicted for Training Set
import matplotlib.pyplot as plt

plt.figure(figsize=(15, 8))
for i in range(10):  # Display 10 images
    plt.subplot(2, 5, i + 1)
    plt.imshow(x_train_batch[i])
    plt.axis('off')
    true_label = label_map[true_train_labels[i]]
    pred_label = label_map[predicted_train_labels[i]]
    color = 'green' if true_label == pred_label else 'red'
    plt.title(f"Actual: {true_label}\nPredicted: {pred_label}", color=color)

plt.tight_layout()
plt.suptitle("üéØ Actual vs Predicted (Train Set)", fontsize=16, y=1.05)
plt.show()



"""Example"""

import cv2
import numpy as np
from tensorflow.keras.models import load_model

def predict_single_image(model, image_path, class_names):
    """
    Predicts the class of a single image using the trained CNN model.

    Args:
        model: The trained Keras model.
        image_path: Path to the input image.
        class_names: List of class names (e.g., ['cat', 'dog', 'horse']).

    Returns:
        predicted_class (str): Name of the predicted class.
        confidence (float): Prediction confidence score.
    """
    try:
        # Load and preprocess image
        img = cv2.imread(image_path)
        if img is None:
            raise ValueError(f"Image not found or unreadable at: {image_path}")

        img = cv2.resize(img, (128, 128))            # Resize to match model input
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)   # Convert BGR to RGB
        img = img.astype("float32") / 255.0          # Normalize to [0, 1]
        img = np.expand_dims(img, axis=0)            # Add batch dimension: (1, 128, 128, 3)

        # Prediction
        predictions = model.predict(img)
        predicted_index = np.argmax(predictions[0])
        predicted_class = class_names[predicted_index]
        confidence = float(np.max(predictions[0]))

        return predicted_class, confidence

    except Exception as e:
        print(f"‚ùå Error during prediction: {e}")
        return None, None

# Load your trained model
model = load_model('/content/skin_disease_cnn_model.h5')

# Define your class labels in correct order
class_names = ['class1', 'class2', 'class3', 'class4', 'class5', 'class6', 'class7']

# Predict
image_path = '/content/skin_dataset_test/Vitiligo 4.jpg'
predicted_class, confidence = predict_single_image(model, image_path, class_names)

if predicted_class:
    print(f"‚úÖ Predicted Class: {predicted_class} (Confidence: {confidence:.2f})")
else:
    print("‚ö†Ô∏è Prediction failed.")

import cv2
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.models import load_model

# Define label mapping
label_map = {
    0: 'acne',
    1: 'alopecia_areata',
    2: 'melasma',
    3: 'pigment',
    4: 'vitiligo',
    5: 'warts',
    6: 'wrinkle'
}

def predict_and_show_image(model, image_path):
    """
    Predicts the class of an image, shows the image, and prints the label + class.

    Args:
        model: Trained Keras model.
        image_path: Path to input image.
    """
    try:
        # Load and preprocess image
        img = cv2.imread(image_path)
        if img is None:
            raise ValueError(f"Image not found at: {image_path}")

        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Convert to RGB for plotting
        img_resized = cv2.resize(img_rgb, (128, 128))   # Resize to model input size
        img_normalized = img_resized.astype('float32') / 255.0
        img_input = np.expand_dims(img_normalized, axis=0)  # Add batch dimension

        # Predict
        prediction = model.predict(img_input)
        predicted_label = int(np.argmax(prediction))
        predicted_class = label_map[predicted_label]
        confidence = float(np.max(prediction))

        # Display image and prediction
        plt.imshow(img_rgb)
        plt.axis('off')
        plt.title(f"Prediction: {predicted_class} (Label: {predicted_label}, Confidence: {confidence:.2f})")
        plt.show()

    except Exception as e:
        print(f"‚ùå Error during prediction or display: {e}")

model = load_model('/content/skin_disease_cnn_model.h5')
image_path = '/content/skin_dataset_test/Alopecia_Areata3.jpg'
predict_and_show_image(model, image_path)

image_path = '/content/skin_dataset_test/acne.jpg'
predict_and_show_image(model, image_path)

